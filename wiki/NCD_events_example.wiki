#summary Event handling example in NCD
#labels ncd,events,volume,suspend

= NCD =

NCD, the Network Configuration Daemon, is a daemon and programming language for configuration of network interfaces and other aspects of the operating system.

This page describes the event handling features of NCD. For a guide to NCD and its basic feaures, see [NCD].

= Introduction =

NCD has some support for imperative-style event handling via the above-described execution model. See [http://code.google.com/p/badvpn/wiki/NCD#Event_handling_and_imperative_style this introduction] first. This page provides a similar example to the DHCP example there, but somehow more complex.

= Goal =

This program responds to volume key presses by synchronously calling an external script for muting and adjusting volume, and responds to power button presses by suspending using pm-suspend.

It uses process_manager() and sys.watch_input() to dynamically create and remove processes that deal with specific input devices. The individual input device processes then use sys.evdev() to handle input events from their input device.

= Code =

{{{
process events_main {
    # Volume control script, called with argument "up", "down" or "mute".
    var("/usr/local/bin/volumekey") volume_script;
    # Suspend command.
    list("/usr/sbin/pm-suspend") suspend_cmd;

    # Provide for accessing configuration from event providers.
    provide("events_config");

    # Create process manager.
    process_manager() manager;

    # Wait for input device events.
    sys.watch_input("event") watcher;

    # Determine if the device is of interest.
    # Volume and power keys are reported by "key" devices.
    strcmp(watcher.device_type, "key") interest;

    # Determine dispatch location.
    strcmp(watcher.event_type, "added") added;
    and(added, interest) dispatch_added;
    strcmp(watcher.event_type, "removed") removed;
    and(removed, interest) dispatch_removed;

    # Dispatch event.
    provide("events_watcher_event");

    # If event was not recognized, finish it here.
    ifnot(dispatch_added);
    ifnot(dispatch_removed);
    watcher->nextevent();
}

process events_watcher_event_added {
    # Wait for event.
    depend("events_watcher_event") evdep;
    if(evdep.dispatch_added);

    # Start event handling process for this device.
    list(evdep.watcher.devname) args;
    evdep.manager->start(evdep.watcher.devname, "events_input_device", args);

    # Finish event.
    evdep.watcher->nextevent();
}

process events_watcher_event_removed {
    # Wait for event.
    depend("events_watcher_event") evdep;
    if(evdep.dispatch_removed);

    # Stop event handling process for this device.
    evdep.manager->stop(evdep.watcher.devname);

    # Finish event.
    evdep.watcher->nextevent();
}

template events_input_device {
    # Alias arguments.
    var(_arg0) dev;

    # Dependency for accessing configuration.
    depend("events_config") config;

    # Wait for input events.
    sys.evdev(dev) evdev;

    # Query event details.
    strcmp(evdev.code, "KEY_MUTE") is_mute;
    strcmp(evdev.code, "KEY_VOLUMEUP") is_vup;
    strcmp(evdev.code, "KEY_VOLUMEDOWN") is_vdown;
    strcmp(evdev.code, "KEY_POWER") is_power;
    strcmp(evdev.value, "1") is_pressed;

    # Compute where to dispatch the event.
    and(is_mute, is_pressed) dispatch_mute;
    and(is_vup, is_pressed) dispatch_vup;
    and(is_vdown, is_pressed) dispatch_vdown;
    and(is_power, is_pressed) dispatch_power;

    # Dispatch event.
    provide_event("events_input_event");

    # Handle unhandled event.
    ifnot(dispatch_mute);
    ifnot(dispatch_vup);
    ifnot(dispatch_vdown);
    ifnot(dispatch_power);

    # Finish unhandled event.
    evdev->nextevent();
}

process events_input_event_mute {
    # Wait for event.
    depend("events_input_event") dep;
    if(dep.dispatch_mute);

    # Process event.
    list(dep.config.volume_script, "mute") cmd;
    runonce(cmd);

    # Finish event.
    dep.evdev->nextevent();
}

process events_input_event_vup {
    # Wait for event.
    depend("events_input_event") dep;
    if(dep.dispatch_vup);

    # Process event.
    list(dep.config.volume_script, "up") cmd;
    runonce(cmd);

    # Finish event.
    dep.evdev->nextevent();
}

process events_input_event_vdown {
    # Wait for event.
    depend("events_input_event") dep;
    if(dep.dispatch_vdown);

    # Process event.
    list(dep.config.volume_script, "down") cmd;
    runonce(cmd);

    # Finish event.
    dep.evdev->nextevent();
}

process events_input_event_power {
    # Wait for event.
    depend("events_input_event") dep;
    if(dep.dispatch_power);

    # Process event.
    runonce(dep.config.suspend_cmd);

    # Finish event.
    dep.evdev->nextevent();
}
}}}